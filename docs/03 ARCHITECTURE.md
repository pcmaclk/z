# zedit 架构宪法（Piece Table 最终版·完整整合）

## 一、项目总纲

### 1.1 项目定位
**zedit** 是一个现代、轻量、跨平台的文本编辑器，定位为系统记事本的现代替代品，并在性能与功能上超越 Notepad2。

### 1.2 核心目标
- ✅ **单文件分发**：最终产物为单个可执行文件
- ✅ **小体积**：Release模式 <5MB，压缩后 <2MB
- ✅ **高性能**：支持大文件（100MB+）流畅编辑与高效撤销
- ✅ **现代外观**：符合各平台设计规范
- ✅ **跨平台**：Windows、macOS、Linux 原生支持

### 1.3 技术栈
- **编程语言**: Rust 1.75+
- **渲染层**: Slint 1.5+（**仅作为渲染和事件捕获层**）
- **文本核心**: **自研的 Piece Table 缓冲区**（为虚拟化与大文件编辑优化）
- **编辑模型**: **事务式状态机**（基于 `EditorAction` / `EditTransaction`）
- **架构模式**: 单向数据流 + 分层设计

### 1.4 核心设计哲学
1.  **状态与渲染分离**：Editor Core 是纯逻辑状态机，不感知任何渲染细节（像素、颜色、动画）。
2.  **数据按需流动**：采用 Pull 模型，由 Viewport 驱动数据查询，确保大文件下仅加载可视内容。
3.  **事务驱动变更**：所有编辑操作都抽象为事务，确保原子性、可撤销性和可合并性。
4.  **渐进式优化**：从简单可靠的实现开始（如线性查找），在性能数据支撑后再引入复杂优化。
5.  **克制功能演进**：所有功能必须与"轻量、大文件友好"的定位强绑定，拒绝功能蔓延。

---

## 二、架构全景图（最终版）

```
    ┌────────────────────────────────────────────┐
    │          Application Framework             │
    │    子系统协调 + Slint主循环集成 + 状态管理  │
    └────────────────────────────────────────────┘
                    │
                    ▼
    ┌────────────────────────────────────────────┐
    │          Slint (仅渲染层)                  │
    │   • 显示虚拟化文本(50-100行)              │
    │   • 捕获并转发原生输入事件                │
    │   • 提供基础UI组件（菜单、对话框）        │
    └────────────────────────────────────────────┘
                    │
                    ▼
    ┌────────────────────────────────────────────┐
    │                Input System                │
    │   • Slint事件 → 归一化 → EditorAction     │
    │   • 快捷键映射（物理键码→语义操作）       │
    │   • IME合成事件处理                       │
    └────────────────────────────────────────────┘
                    │
                    ▼
    ┌────────────────────────────────────────────┐
    │              Editor Core                   │
    │    • Piece Table 缓冲区（权威状态）        │
    │    • 单光标 + 流式/矩形选区管理           │
    │    • 事务执行与历史栈                      │
    │    • 接收Action，发布StateSnapshot         │
    └────────────────────────────────────────────┘
                    │
                    ▼
    ┌────────────────────────────────────────────┐
    │           Viewport System                  │
    │   • 计算与维护"可见行范围"                 │
    │   • 向Editor Core"拉取"视口数据            │
    │   • 管理滚动逻辑与同步                     │
    └────────────────────────────────────────────┘
                    │
                    ▼
    ┌────────────────────────────────────────────┐
    │          EditorViewModel Pipeline          │
    │   • 将逻辑状态转换为渲染友好的快照         │
    │   • 集成语法高亮、搜索结果等装饰信息       │
    │   • 输出只读的ViewModel                   │
    └────────────────────────────────────────────┘
                    │
                    ▼
    ┌────────────────────────────────────────────┐
    │              Layout System                 │
    │   • 文本 → 行 → glyph → 物理坐标           │
    │   • 处理字体、换行、DPI缩放               │
    └────────────────────────────────────────────┘
                    │
                    ▼
    ┌────────────────────────────────────────────┐
    │           Render System (Slint适配层)      │
    │   • 将Layout数据绑定到Slint组件            │
    │   • 管理Slint绘制命令队列与资源            │
    │   • 处理增量更新与脏区域优化               │
    └────────────────────────────────────────────┘
```

---

## 三、横向支撑系统

```
                    ┌──────────────────────┐
                    │      IO System       │
                    │    • 文件内存映射    │
                    │    • 编码检测/转换   │
                    │    • 滑动窗口映射    │
                    └──────────────────────┘
                               ▲
                               │
                    ┌──────────────────────┐
                    │      Editor Core     │
                    │     (Piece Table)    │
                    └──────────────────────┘
                               ▲
                               │
    ┌──────────────────────┐     ┌──────────────────────┐
    │   Search System      │────▶│  EditorViewModel     │
    │    • 后台搜索        │     │     (高亮融合)       │
    │    • 结果缓存        │     └──────────────────────┘
    └──────────────────────┘
```

```
┌──────────────────────┐    ┌──────────────────────┐
│   Syntax Highlight   │    │   Config/Theme/i18n  │
│    • 自定义lexer     │    │    • 纯数据管理      │
│    • 行级增量分析    │    │    • Slint样式适配   │
│    • 异步/延迟任务   │    └──────────────────────┘
└──────────────────────┘            ▲        ▲
        │                          │        │
        ▼                    Render System  ViewModel Pipeline
    ViewModel Pipeline
```

---

## 四、子系统宪法（一句话定义）

### 1️⃣ Application Framework
> 协调所有子系统，集成Slint事件循环，管理应用生命周期。

### 2️⃣ Slint渲染层
> 仅负责渲染显示和原始事件捕获，不包含任何编辑器业务逻辑。

### 3️⃣ Input System
> 将Slint捕获的物理输入（键鼠、IME）翻译成抽象的 `EditorAction`，包含快捷键映射和输入法处理。

### 4️⃣ **Editor Core（重新定义）**
> **编辑器中唯一的真相源与状态机**。基于Piece Table管理文档、光标、选区状态，接收`EditorAction`，通过事务模型更新状态，并发布`EditorStateSnapshot`。

### 5️⃣ Edit Transaction System（内置于 Core）
> 保证编辑操作的原子性，管理由`EditorAction`产生的`EditTransaction`，并维护`UndoStack`与`RedoStack`。

### 6️⃣ Viewport System
> 连接逻辑与渲染的桥梁。维护可见区域，主动向Editor Core"拉取"数据，并保证用户关注点（光标、选区）始终可见。

### 7️⃣ EditorViewModel Pipeline
> 将`EditorStateSnapshot`与语法、搜索等装饰信息融合，生成与渲染无关但便于布局的`ViewModel`。

### 8️⃣ Layout System
> 将`ViewModel`中的文本和装饰转换为精确的物理坐标和几何信息，不关心编辑语义。

### 9️⃣ Render System (Slint适配层)
> 将`Layout`数据转换为Slint的绘制命令与组件状态，管理渲染任务队列与资源。

### 🔟 IO System
> 提供统一、高效的文件访问接口（内存映射、编码处理、大文件滑动窗口），支撑Piece Table的物理存储。

### 1️⃣1️⃣ Search System
> 提供异步文本搜索能力，与编辑器状态解耦，通过`ViewModel`集成高亮结果。

### 1️⃣2️⃣ Syntax Highlight System
> 提供语法高亮分析能力，采用自定义lexer（正则+状态机），支持行级增量分析和异步任务调度。

### 1️⃣3️⃣ Theme/Config System
> 管理外观和配置的纯数据，不参与编辑逻辑，通过`Render System`影响Slint样式。

---

## 五、三条架构铁律（更新）

### 🟥 铁律 1：禁止逆向依赖
```
Render ❌→ Editor
Layout ❌→ Editor
ViewModel ❌→ Action
Slint UI ❌→ 任何业务逻辑子系统
Syntax Highlight ❌→ Editor State（仅读数据）
```
一旦出现，**架构立刻腐化**。

### 🟥 铁律 2：跨子系统只能通过"定义良好的产物"
| 子系统 | 对外输出产物 |
|--------|--------------|
| Slint渲染层 | 原生事件 (`SlintEvent`) |
| Input System | `EditorAction` |
| **Editor Core** | **`EditorStateSnapshot`**、`ViewportDirtyNotification` |
| Viewport System | `ViewportQuery` (请求) |
| ViewModel Pipeline | `ViewModel` (渲染快照) |
| Layout System | `LayoutModel` (几何数据) |
| Render System | `SlintDrawCommand` (绘制指令) |
| Search System | `SearchResult` (搜索结果集) |
| Syntax System | `SyntaxTokens` (词法标记) |

### 🟥 铁律 3：任何复杂度只能存在于一个子系统
- **Piece链管理、字节偏移计算** → `Editor Core` (Piece Table)
- **事务合并、撤销策略** → `Edit Transaction System`
- **光标移动算法** → `Editor Core` (Cursor)
- **矩形选区算法** → `Editor Core` (Selection)
- **视口跟随、自动滚动** → `Viewport System`
- **文本换行、坐标计算** → `Layout System`
- **Slint组件生命周期** → `Render System`
- **词法分析状态机** → `Syntax Highlight System`
- **编码检测与转换** → `IO System`

---

## 六、核心设计决策（最终版）

### 6.1 文本缓冲区：Piece Table
- **模型**：维护 `original_buffer` (内存映射) 和 `add_buffer` (追加)，通过不可变的 `Piece` 链索引定义文档。
- **优势**：
    1.  **大文件友好**：打开大文件仅建立映射，不读数据。
    2.  **撤销高效**：事务的本质是变更 `Piece` 链，可轻量级记录。
    3.  **天然虚拟化**：`Viewport` 可按需查询任意行范围对应的 `Piece` 内容。
- **大文件优化**：
    - ≤50MB：完整内存映射
    - >50MB：滑动窗口映射（仅映射活动区域）
    - >200MB：提示用户进入"受限模式"
- **内部权威**：`byte offset`（字节偏移量），逻辑行列仅为外部友好接口。

### 6.2 编辑模型：事务式状态机
- **输入**：`EditorAction`，代表用户意图（如`InsertText`，`MoveCursor`）。
- **处理**：`Editor Core` 将 `Action` 转换为一个或多个 `EditTransaction` 并执行。
- **输出**：`EditorStateSnapshot`，包含新的完整状态与 `dirty_range`（脏区）。
- **历史**：`UndoStack` 存储 `EditTransaction`（含逆操作），采用 **FIFO容量淘汰**（初期），未来可升级为基于内存预算的智能合并。

### 6.3 虚拟化策略：三级按需
1.  **存储虚拟化 (Piece Table)**：原始文件内容按操作系统页需求加载。
2.  **数据虚拟化 (Viewport)**：`Editor Core` 仅提供`Viewport Query`请求的特定行范围数据。
3.  **渲染虚拟化 (Slint)**：Slint ListView 仅渲染可视区域内的行。

### 6.4 光标与选区模型
- **主光标**：单个 `Cursor`，支持复杂移动逻辑。
- **选区模式**：
  - **流式选区**：连续字符范围（基础模式）
  - **矩形选区**：列选择（P0基础可视化，P1删除，P2完整编辑）
- **明确不实现**：多光标（保持架构简洁）

### 6.5 语法高亮策略（分级实现）
- **实现**：自定义lexer（正则+状态机），非tree-sitter
- **分级策略**：
  - **≤10MB文件**：全文件分析 + 缓存，延迟更新
  - **10MB~50MB**：仅分析视口内行（±50行缓冲区），轻度缓存
  - **>50MB文件**：仅分析当前视口内的行（无缓存，最低优先级）
  - **>200MB文件**：提供手动开关，用户可选择关闭
- **性能保证**：分析任务异步、可中断，绝不阻塞UI线程

### 6.6 列编辑实现策略
- **P0（基础）**：矩形选区可视化，无编辑能力
- **P1（实用）**：列删除（作为`Delete`操作的特殊模式）
- **P2（完整）**：列插入、替换、粘贴（独立事务类型）
- **P3（增强）**：列对齐、数字序列填充
- **技术实现**：列操作 = 多个独立行操作的集合，完全基于现有事务模型

---

## 七、数据流规范（最终版）

### 7.1 完整正向流程（编辑到渲染）
```
1. Slint捕获事件 → Input System（归一化、映射、IME） → EditorAction
2. EditorAction → Editor Core
3. Editor Core 执行事务 → 更新内部状态 → 发布 EditorStateSnapshot
4. Viewport System 接收 Snapshot（含dirty_range）→ 决定是否需要新数据
5. Viewport 向 Editor Core 发起 ViewportQuery（如需新数据）
6. Editor Core 返回 ViewportData（纯逻辑）
7. ViewportData → ViewModel Pipeline → ViewModel（+语法/搜索高亮）
8. ViewModel → Layout System → LayoutModel（几何坐标）
9. LayoutModel → Render System → SlintDrawCommand
10. SlintDrawCommand → Slint渲染引擎 → 屏幕像素
```

### 7.2 核心接口：`Editor Core` 的输入与输出
```rust
trait EditorCore {
    /// 应用编辑动作，返回新状态快照
    fn apply_action(&mut self, action: EditorAction) -> Result<EditorStateSnapshot>;
    
    /// 查询视口数据（按需拉取）
    fn query_viewport(&self, query: ViewportQuery) -> ViewportData;
    
    /// 订阅视口脏区通知（可选，优化用）
    fn subscribe_dirty_notification(&self, subscriber: impl Fn(ViewportDirtyNotification));
}

struct EditorStateSnapshot {
    version: u64,                     // 状态版本号
    dirty_range: Option<ByteRange>,   // 脏区范围（用于增量更新）
    can_undo: bool,                   // UI状态
    can_redo: bool,
    selection: Selection,             // 当前选区
    // 其他状态...
}
```

### 7.3 状态更新传播
当 `EditorStateSnapshot.dirty_range` 为 `Some(range)` 时，下游系统（`Viewport`， `ViewModel`）可进行**增量计算与更新**，大幅提升性能。

---

## 八、性能目标（基于新架构）

### 8.1 响应时间
- **启动时间**：冷启动 <1秒（含初始化Piece Table内存映射）
- **大文件打开**：
  - 10MB文件 <0.5秒
  - 100MB文件 <2秒（仅建立映射，不读数据）
  - 1GB文件 <5秒（滑动窗口映射）
- **编辑响应**：按键到屏幕更新 <16ms (60 FPS)
- **视口滚动**：滚动到新区域首帧渲染 <50ms（含可能的磁盘IO）

### 8.2 内存占用
- **基础占用**：<50MB（包含Slint运行时）
- **文件内存**：**与文件大小解耦**。物理内存占用 ≈ 内存映射开销 + 编辑增量大小 + 当前视口内容大小。
- **大文件模式**：
  - 10MB~50MB：正常模式
  - 50MB~200MB：降级模式（减少撤销深度、简化语法分析）
  - >200MB：受限模式（关闭非核心功能）

### 8.3 核心指标验证
性能测试将重点关注：
1.  100MB文件打开后的内存工作集（Working Set）。
2.  长时间输入后的撤销栈内存增长曲线。
3.  快速滚动时的帧率稳定性与IO读取量。
4.  语法高亮在不同文件大小下的CPU占用率。

---

## 九、开发阶段规划（最终版）

### Phase 1：核心MVP（验证架构）
**目标**：产出"能长期使用的记事本替代品"核心，验证架构通路
**P0全部 + P1部分**：
- [ ] Piece Table + 事务模型核心完成
- [ ] 单光标、流式选区、矩形选区可视化
- [ ] 基础编辑（输入、删除、复制粘贴）
- [ ] 基础撤销/重做（50步）
- [ ] Slint集成，完整单向数据流验证
- [ ] 大文件基础支持（10MB+流畅）
- [ ] 基础查找（无替换）
- [ ] 状态栏（行/列、编码）
- [ ] **矩形选区删除**（列编辑基础）
- [ ] 性能目标达成验证

### Phase 2：完整编辑器
**目标**：成为功能完整的轻量级编辑器，满足日常所有需求
**P1剩余 + P2核心**：
- [ ] 多标签页支持
- [ ] 简单语法高亮（分级实现）
- [ ] 查找替换（基础）
- [ ] 完整列编辑（插入、替换、粘贴）
- [ ] 文本转换工具（选区限定）
- [ ] 行整理工具（选区限定）
- [ ] 行操作工具（选区限定）
- [ ] 配置文件、主题记忆
- [ ] 文件修改状态感知
- [ ] 拖放支持

### Phase 3：效率增强
**目标**：在稳定基础上增加提升效率的"锦上添花"功能
**P2剩余 + 精选P3**：
- [ ] 简单代码折叠
- [ ] 格式化工具（JSON/XML）
- [ ] 跳转功能
- [ ] 文本工具增强（行对齐、计算器等）
- [ ] 列编辑增强（对齐、序列填充）
- [ ] 编码扩展（UTF-16、GBK）
- [ ] 国际化完善

---

## 十、功能约束与边界（最终冻结）

### 10.1 明确支持的功能边界
- ✅ **选区限定的文本工具**：所有高级编辑工具仅对选中区域生效
- ✅ **渐进式语法高亮**：根据文件大小自动降级，绝不阻塞UI
- ✅ **分级列编辑**：从可视化→删除→完整编辑分阶段实现
- ✅ **大文件友好**：从架构层面保证大文件性能

### 10.2 明确不支持的领域（架构禁令）
- ❌ **插件系统**：保持单文件分发，不开放扩展
- ❌ **LSP/tree-sitter**：不引入复杂语法分析
- ❌ **多光标**：保持核心简洁
- ❌ **侧边栏/文件树**：专注纯文本编辑
- ❌ **版本控制集成**：超出记事本替代品定位
- ❌ **动画效果**：性能优先
- ❌ **Web技术栈**：保持原生性能

### 10.3 技术债务管理原则
1.  **每完成一个Phase，必须进行性能回归测试**
2.  **新功能必须附带基准测试用例**
3.  **架构文档随代码演进同步更新**
4.  **发现架构违反（铁律）立即重构，不妥协**

---

## 十一、总结

本《架构宪法》是zedit项目的**最高设计纲领**，整合了：

1.  **技术架构**：Piece Table + 事务模型 + 单向数据流
2.  **功能规划**：克制、渐进、与架构强一致的功能列表
3.  **质量目标**：明确的性能指标与验收标准
4.  **演进路径**：清晰的三个阶段开发路线

**核心承诺**：
- 对用户：提供**轻量、快速、稳定**的文本编辑体验
- 对开发者：维护**清晰、可维护、可测试**的代码架构
- 对项目：坚持**克制、聚焦、高质量**的演进方向

此宪法为zedit的所有开发工作提供了**不可违背的架构基础**，所有代码实现必须严格遵循此文档定义的原则与边界。

---
**文档版本**：v2.0（最终版）  
**生效日期**：即日起  
**修改原则**：重大架构变更需重新评审并更新此宪法